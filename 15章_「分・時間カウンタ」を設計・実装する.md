# 15章 「分/時間カウンタ」を設計・実装する

- 「分/時間カウンタ」を作成して，これまでのおさらいをする
  - ウェブサーバの直近1分間と直近1時間の転送バイト数を把握する機能

## 15.2 インターフェースを定義

### 名前を改善
### コメントを改善

## 試案1:素朴な解決策

- タイムスタンプのついた「イベント」のリストを保持する

- forの読みやすさの改善
- コードの重複を削除するために関数追加

### パフォーマンス問題

1. 古いイベントも持ち続けるので無限にメモリを使う
2. `MinuteCount()`と`HourCount()`が遅すぎる（対象のデータ数に対して$O(n)$）

## 試案2:ベルトコンベヤー設計

- 直近1分と1時間のイベントのリスト，カウントの値を持っておく
  - 古いデータは削除され，メモリ問題が改善する
  - `MinuteCount()`と`HourCount()`は，用意しておいた値を参照するだけなので$O(1)$

### 問題点
- 柔軟性がない
  - カウントしたい時間の範囲を変更するのが大変
- メモリ使用量が多い
  - Addに頻度によっては大量にメモリを消費する

## 試案3:時間バケツの設計
- 直近１分のイベントは１秒単位，直近１時間のイベントは１分単位のカウントとしてまとめて保存する
  - 精度は落ちるがそこまで深刻ではない
  - メモリ使用料はAddの頻度に左右されず一定

- 時間経過に伴うデータの管理と，カウントや合計を行う処理を別クラスに分離
  - `TrailingBucketCounter`では時間経過に伴ってコンベヤーを動かすタスクを行う
  - `ConveyorQueue`ではカウントや合計の保持を行う

## 3角解決策を比較

## まとめ

- 素朴な解決策
  - 速度とメモリ使用量の課題
- ベルトコンベヤー
  - メモリの改善はしたが，まだ足りない
  - 柔軟性の問題
- 時間バケツ
  - 複数の下位問題に分割することで問題を解決

- `ConveyorQueue`
  - 最大長のあるキュー。
  - 「シフト」可能で合計値を保持する
- `TrailingBucketCounter`
  - 時間経過に伴って`ConveyorQueue`を移動する。
  - 一つの時間帯のカウントを任意の制度で保持する。
- `MinuteHourCounter`
  - 2つの`TrailingBucketCounter`を保持する